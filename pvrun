#!/usr/bin/env python3

import sys
import os

from paravision.utils import parse_cmdline_args, read_files, parse_outer_args

import importlib
import subprocess


def run_command(module:str, args:list, nproc:int=1):

    ## Needed because subprocess.run couldn't find modules
    myenv = os.environ
    pythonpath = os.pathsep.join(sys.path)
    myenv.update({'PYTHONPATH': pythonpath})

    if nproc > 1:
        command_pre = [ 'mpiexec', '-np', str(nproc), 'pvbatch' ]
        pvbatch_path = subprocess.run(['which', 'pvbatch'], capture_output=True, env=myenv)
        print(f"Using pvbatch from path: {pvbatch_path.stdout.decode('ascii').strip()}")
        mpiexec_path = subprocess.run(['which', 'mpiexec'], capture_output=True, env=myenv)
        print(f"Using mpiexec from path: {mpiexec_path.stdout.decode('ascii').strip()}")
    else:
        command_pre = [ 'pvpython' ]
        pvpython_path = subprocess.run(['which', 'pvpython'], capture_output=True, env=myenv)
        print(f"Using pvpython from path: {pvpython_path.stdout.decode('ascii').strip()}")

    command = []
    command.extend([importlib.util.find_spec(module).origin])
    command.extend(args)

    command = command_pre + command

    print(command)
    subprocess.run(command)


def main():

    args, subargs = parse_outer_args()

    argv_sub = sys.argv[1:]
    # argv_sub = subargs

    if args.chromatogram:
        run_command("paravision.chromatogram", argv_sub, args.nproc)
    elif args.shell_chromatograms:
        run_command("paravision.shell_chromatograms", argv_sub, args.nproc)
    elif args.grm2d:
        run_command("paravision.grm2d", argv_sub, args.nproc)
    elif args.radial_shell_integrate:
        run_command("paravision.radial_shell_integrate", argv_sub, args.nproc)
    elif args.column_snapshot:
        run_command("paravision.column_snapshot", argv_sub, args.nproc)
    elif args.column_snapshot_fast:
        run_command("paravision.column_snapshot_fast", argv_sub, args.nproc)
    elif args.volume_integral:
        run_command("paravision.volume_integral", argv_sub, args.nproc)
    elif args.bead_loading:
        run_command("paravision.bead_loading", argv_sub, args.nproc)
    elif args.mass_flux:
        run_command("paravision.mass_flux", argv_sub, args.nproc)
    elif args.animate:
        run_command("paravision.animate", argv_sub, args.nproc)
    elif args.screenshot:
        run_command("paravision.screenshot", argv_sub, args.nproc)
    elif args.infogeneric:
        run_command("paravision.infogeneric", argv_sub, args.nproc)
    elif args.pipeline:
        ## NOTE: Pipeline operations below [EXPERIMENTAL]
        ## NOTE: Doesn't work in parallel!!
        ## The idea is to provide the sequence of operations on the commandline
        ##  and execute it here
        from paravision.project import project
        from paravision.screenshot import screenshot
        supported_operations = {
            'project': project,
            'screenshot': screenshot
        }

        reader = read_files(args['FILES'], filetype=args['filetype'])
        object = reader
        args.pipeline = args.pipeline or []

        for operation in args.pipeline:
            object = supported_operations[operation](object, args)

if __name__ == "__main__":
    main()
